#' @section Stats:
#'
#' All \code{stat_*} functions (like \code{stat_bin}) return a layer that
#' contains a \code{Stat*} object (like \code{StatBin}). The \code{Stat*}
#' object is responsible for rendering the data in the plot.
#'
#' Each of the \code{Stat*} objects is a \code{\link{ggproto}} object, descended
#' from the top-level \code{Stat}, and each implements various methods and
#' fields. To create a new type of Stat object, you typically will want to
#' implement one or more of the following:
#'
#' \itemize{
#'   \item \code{calculate}: Calculates a stat for a single group of data.
#'   \item \code{calculate_groups}: Calculates stat for all groups. The method
#'     typically calls \code{calculate} for each group.
#'   \item \code{compute_defaults(data, params)}: called once for each layer.
#'      Used to compute defaults that need to complete dataset, and to inform
#'      the user of important choices.
#'   \item \code{required_aes}: A character vector of aesthetics needed to
#'     render the geom.
#'   \item \code{default_aes}: A list (generated by \code{\link{aes}()} of
#'     default values for aesthetics.
#' }
#' @rdname ggplot2-ggproto
#' @format NULL
#' @usage NULL
#' @export
Stat <- ggproto("Stat",
  # Should the values produced by the statistic also be transformed
  # in the second pass when recently added statistics are trained to
  # the scales
  retransform = TRUE,

  default_aes = aes(),

  required_aes = c(),

  calculate = function(data, scales, ...) {
    data
  },

  compute_defaults = function(data, params) {
    params
  },

  calculate_groups = function(self, data, scales, ...) {
    if (empty(data)) return(data.frame())

    force(data)
    force(scales)

    # # Alternative approach: cleaner, but much slower
    # # Compute statistic for each group
    # stats <- ddply(data, "group", function(group) {
    #   self$calculate(group, scales, ...)
    # })
    # stats$ORDER <- seq_len(nrow(stats))
    #
    # # Combine statistics with original columns
    # unique <- ddply(data, .(group), uniquecols)
    # stats <- merge(stats, unique, by = "group")
    # stats[stats$ORDER, ]

    groups <- split(data, data$group)
    stats <- lapply(groups, function(group)
      self$calculate(data = group, scales = scales, ...))

    stats <- mapply(function(new, old) {
      if (empty(new)) return(data.frame())
      unique <- uniquecols(old)
      missing <- !(names(unique) %in% names(new))
      cbind(
        new,
        unique[rep(1, nrow(new)), missing,drop = FALSE]
      )
    }, stats, groups, SIMPLIFY = FALSE)

    do.call(plyr::rbind.fill, stats)
  }
)

# make_stat("bin") returns StatBin
make_stat <- function(class) {
  name <- paste0("Stat", camelize(class, first = TRUE))
  if (!exists(name)) {
    stop("No stat called ", name, ".", call. = FALSE)
  }

  obj <- get(name)
  if (!inherits(obj, "Stat")) {
    stop("Found object is not a stat", call. = FALSE)
  }

  obj
}
